use anyhow::{Context, Result};
use clap::Parser;
use log::{debug, error, info, log_enabled, Level};
use std::time::{Duration, SystemTime};
use tokio::io::{
    split, AsyncBufReadExt, AsyncReadExt, AsyncWriteExt, BufReader, ReadHalf, WriteHalf,
};
use tokio::time::sleep;
use tokio::{select, spawn};
use tokio_serial::FlowControl;
use tokio_serial::SerialStream;

fn epoch_seconds() -> Result<u64> {
    Ok(SystemTime::now()
        .duration_since(SystemTime::UNIX_EPOCH)
        .as_secs())
}

async fn writer_task(mut writer: WriteHalf<SerialStream>) -> Result<()> {
    let invalid_utf8 = &[0xffu8, 0xffu8, 0xffu8, 0x0au8, 0x0du8];
    let valid_utf8__ = b"Now is the time for all good men to come to the aid of the party\n";
    loop {
        if epoch_seconds()? % 10 == 0 {
            writer
                .write_all(invalid_utf8)
                .await
                .context("writer_task")?;
        } else {
            writer
                .write_all(valid_utf8__)
                .await
                .context("writer_task")?;
        }
        sleep(Duration::from_millis(1000)).await;
    }
}

async fn line_reader_task(reader: ReadHalf<SerialStream>) -> Result<()> {
    let buf_reader = BufReader::new(reader);

    let mut lines = buf_reader.lines();
    loop {
        match lines.next_line().await.context("Error on reading line")? {
            Some(line) => {
                info!("Serial got: {:?}", line);
            }
            None => error!("Serial got: empty line."),
        }
    }
}

async fn bytes_reader_task(mut serial_reader: ReadHalf<SerialStream>) -> Result<()> {
    let mut buf = [0u8; 256];
    loop {
        let n = serial_reader
            .read(&mut buf)
            .await
            .context("Error on read:")?;
        info!("Serial got: {:x?}", &buf[0..n]);
    }
}

async fn test_serial(path: String, baud_rate: u32) -> Result<()> {
    info!("Using serial port: {path} at {baud_rate} baud.");
    let port_builder = tokio_serial::new(path.clone(), baud_rate).flow_control(FlowControl::None);
    let mut stream = SerialStream::open(&port_builder)?;
    stream
        .set_exclusive(false)
        .context(format!("Failed to set port as exclusive"))?;
    let (serial_reader, serial_writer) = split(stream);

    let writer_handle = spawn(async move { writer_task(serial_writer) })
        .await
        .context("test_serial")?;
    let reader_handle = spawn(async move { line_reader_task(serial_reader) })
        .await
        .context("test_serial()")?;

    tokio::select! {
        val = writer_handle => {
            match val {
                Ok(v) => error!("writer task completed with value {:?}", v),
                Err(e) => error!("writer task completed with error: {:?}", e),
            }
        }

        val = reader_handle => {
            match val {
                Ok(x) => error!("reader task completed with value {:?}", x),
                Err(e) => error!("reader task completed with error: {:?}", e),
            }
        }
    }
    Ok(())
}

async fn test_runner(path: String, baud_rate: u32) -> Result<()> {
    loop {
        let path = path.clone();

        let f = tokio::spawn(async move { test_serial(path, baud_rate) })
            .await
            .context("test_runner()")?
            .await;
        match f {
            Ok(()) => {}
            Err(e) => {
                info!("Error: {e}");
            }
        }
        info!("Test looping...");
        sleep(Duration::from_millis(1000)).await;
    }
}

/// Simple program using Tokio to test serial ports
#[derive(Parser, Debug)]
#[command(author, version, about, long_about)]
struct Args {
    /// Baud rate
    #[arg(short, long, default_value = 921600)]
    baud_rate: u32,

    /// First serial port
    #[arg(short, long, default_value = "/dev/ttyUSB0")]
    first_port: String,

    /// Second serial port
    #[arg(short, long, default_value = "/dev/ttyUSB0")]
    second_port: String,
}

#[tokio::main]
async fn main() {
    env_logger::init();

    let args = Args::parse();

    select! {
        _ = test_runner(args.first_port, args.baud_rate) => {error!("Failed to run test 1 ")},
        _ = test_runner(args.second_port, args.baud_rate) => {error!("Failed to run test 2")},
    }
    error!("Eek! Should never get here.")
}
